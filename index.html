<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js AR - Hit Test (CDN version)</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />

    <!-- Optional basic styling -->
    <style>
      body, html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: sans-serif;
      }
      #info {
        position: absolute;
        top: 10px; left: 10px;
        color: #fff;
        z-index: 999;
        background: rgba(0,0,0,0.5);
        padding: 5px 10px;
        border-radius: 4px;
      }
    </style>

    <!-- 
      Import map: Tells the browser how to resolve "three" and "three/addons/" 
      references. We're using unpkg's CDN for everything.
    -->
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.146.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.146.0/examples/jsm/"
      }
    }
    </script>
  </head>
  <body>
    <div id="info">
      <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> AR - Hit Test (CDN)
    </div>

    <script type="module">
      import * as THREE from 'three';
      import { ARButton } from 'three/addons/webxr/ARButton.js';

      let camera, scene, renderer;
      let controller;

      let reticle;              // a visual marker that shows where the hit test intersects
      let hitTestSource = null; // reference to an XR hit test source
      let hitTestSourceRequested = false;

      init();

      function init() {

        // Scene setup
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        // Basic light
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
        light.position.set(0.5, 1, 0.25);
        scene.add(light);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // AR Button (requests AR session w/ hit-test)
        document.body.appendChild(ARButton.createButton(renderer, {
          requiredFeatures: ['hit-test']
        }));

        // Create a reticle for visualizing the hit test position
        reticle = new THREE.Mesh(
          new THREE.RingGeometry(0.15, 0.20, 32).rotateX(-Math.PI / 2),
          new THREE.MeshBasicMaterial()
        );
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);

        // Controller: handle "select" events (tap)
        controller = renderer.xr.getController(0);
        controller.addEventListener('select', onSelect);
        scene.add(controller);

        window.addEventListener('resize', onWindowResize);

        // Begin render loop
        renderer.setAnimationLoop(animate);
      }

      function onSelect() {
        // Place a simple object (a cylinder) where the reticle is
        if (reticle.visible) {
          const geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.2, 32).translate(0, 0.1, 0);
          const material = new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff });
          const mesh = new THREE.Mesh(geometry, material);

          // Copy the reticle transform into the mesh
          reticle.matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);

          // Random scale just for fun
          mesh.scale.y = Math.random() * 2 + 1;

          scene.add(mesh);
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate(timestamp, frame) {
        if (frame) {
          const referenceSpace = renderer.xr.getReferenceSpace();
          const session = renderer.xr.getSession();

          // If we have not yet requested a hitTestSource, do so now
          if (!hitTestSourceRequested) {
            session.requestReferenceSpace('viewer').then((viewerSpace) => {
              session.requestHitTestSource({ space: viewerSpace }).then((source) => {
                hitTestSource = source;
              });
            });

            session.addEventListener('end', () => {
              hitTestSourceRequested = false;
              hitTestSource = null;
            });

            hitTestSourceRequested = true;
          }

          if (hitTestSource) {
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length > 0) {
              const hit = hitTestResults[0];
              const pose = hit.getPose(referenceSpace);

              if (pose) {
                // Update reticle position
                reticle.visible = true;
                reticle.matrix.fromArray(pose.transform.matrix);
              }
            } else {
              reticle.visible = false;
            }
          }
        }

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
